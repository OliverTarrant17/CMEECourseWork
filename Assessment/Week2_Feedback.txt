Starting weekly assessment for Oliver, Week2

Current Marks = 100

Note that: 
(1) Major sections begin with a double "====" line 
(2) Subsections begin with a single "====" line 
(3) Code output or text file content are printed within single "*****" lines 

======================================================================
======================================================================
Your Git repo size this week is about 3.06 MiB on disk 

PART 1: Checking project workflow...

Found the following directories in parent directory: Week1, Assessment, Week2, .git, Week3

Found the following files in parent directory: README.txt, .gitignore

Checking for key files in parent directory...

Found .gitignore in parent directory, great! 

Printing contents of .gitignore:
**********************************************************************
*~ 
*.tmp
*.pyc
**********************************************************************

Found README in parent directory, named: README.txt

Printing contents of README.txt:
**********************************************************************
My CMEE 2017-18 Coursework Repository
Do I like this better?

.
├── README.txt
├── temporary.tmp
├── Week1
│   ├── Code
│   │   ├── boilerplate.sh
│   │   ├── CompileLatex.sh
│   │   ├── ConcatenateTwoFiles.sh
│   │   ├── CountLines.sh
│   │   ├── csvtospace.sh
│   │   ├── FirstBiblio.bib
│   │   ├── FirstExample.tex
│   │   ├── MyExampleScript.sh
│   │   ├── Results
│   │   │   └── FirstExample.pdf
│   │   ├── tabtocsv.sh
│   │   ├── UnixPrac1.txt
│   │   └── variables.sh
│   ├── Data
│   │   ├── fasta
│   │   │   ├── 407228326.fasta
│   │   │   ├── 407228412.fasta
│   │   │   └── E.coli.fasta
│   │   ├── spawannxs.txt
│   │   └── Temperatures
│   │       ├── 1800.csv
│   │       ├── 1800.csv_space
│   │       ├── 1801.csv
│   │       ├── 1801.csv_space
│   │       ├── 1802.csv
│   │       ├── 1802.csv_space
│   │       ├── 1803.csv
│   │       └── 1803.csv_space
│   ├── readme
│   └── Sandbox
│       ├── ListRootDir.txt
│       ├── TestFind
│       │   ├── Dir1
│       │   │   ├── Dir11
│       │   │   │   └── Dir111
│       │   │   │       └── File111.txt
│       │   │   ├── File1.csv
│       │   │   ├── File1.tex
│       │   │   └── File1.txt
│       │   ├── Dir2
│       │   │   ├── file2.csv
│       │   │   ├── File2.tex
│       │   │   └── File2.txt
│       │   └── Dir3
│       │       └── File3.txt
│       ├── TestLaTex.tex
│       ├── test.txt
│       ├── test.txt.csv
│       └── TestWild
│           ├── Anotherfile.csv
│           ├── Anotherfile.txt
│           ├── File1.csv
│           ├── File1.txt
│           ├── File2.csv
│           ├── File2.txt
│           ├── File3.csv
│           ├── File3.txt
│           ├── File4.csv
│           └── File4.txt
├── Week2
│   ├── Code
│   │   ├── align_seq.py
│   │   ├── align_seqs_fasta.py
│   │   ├── basic_csv.py
│   │   ├── basic_io.py
│   │   ├── boilerplate.py
│   │   ├── boilerplate.pyc
│   │   ├── cfexercises.py
│   │   ├── cfexercises.pyc
│   │   ├── control_flow.py
│   │   ├── debugme.py
│   │   ├── dictionary.py
│   │   ├── lc1.py
│   │   ├── lc2.py
│   │   ├── loops.py
│   │   ├── LV1.py
│   │   ├── LV1.pyc
│   │   ├── LV2.py
│   │   ├── LV2.pyc
│   │   ├── LV3.py
│   │   ├── LV4.py
│   │   ├── oaks.py
│   │   ├── profileme.py
│   │   ├── run_LV.py
│   │   ├── scope.py
│   │   ├── sysargv.py
│   │   ├── test_control_flow.py
│   │   ├── test_control_flow.pyc
│   │   ├── test_oaks.py
│   │   ├── timeitme.py
│   │   ├── timeitme.pyc
│   │   ├── tuple.py
│   │   ├── using_name.py
│   │   └── using_name.pyc
│   ├── Data
│   │   ├── bodymass.csv
│   │   ├── fasta
│   │   │   ├── 407228326.fasta
│   │   │   ├── 407228412.fasta
│   │   │   └── E.coli.fasta
│   │   ├── Sequences.csv
│   │   ├── testcsv.csv
│   │   └── TestOaksData.csv
│   ├── README
│   ├── Results
│   │   ├── align_407228326.fasta_407228412.fasta
│   │   ├── align_407228326.fasta_E.coli.fasta
│   │   ├── align_407228412.fasta_E.coli.fasta
│   │   ├── align_too_few_args_have_an_example
│   │   ├── JustOaksData.csv
│   │   ├── prey_and_predators_1.pdf
│   │   ├── prey_and_predators_2.pdf
│   │   ├── prey_and_predators_3.pdf
│   │   └── Sequences_aligned.txt
│   └── Sandbox
│       ├── temp.py
│       ├── testout.txt
│       ├── testp.p
│       └── test.txt
└── Week3
    ├── Code
    │   ├── apply1.R
    │   ├── apply2.R
    │   ├── basic_io.R
    │   ├── boilerplate.R
    │   ├── break.R
    │   ├── browser.R
    │   ├── control.R
    │   ├── get_TreeHeight.R
    │   ├── next.R
    │   ├── Ricker.R
    │   ├── run_get_TreeHeight.sh
    │   ├── sample.R
    │   ├── SQLinR.R
    │   ├── stochrickvect.R
    │   ├── TreeHeight.R
    │   ├── try.R
    │   ├── Vectorize1.R
    │   └── Vectorize2.R
    ├── Data
    │   ├── Resource.csv
    │   └── trees.csv
    ├── README
    ├── Results
    │   ├── MyData.csv
    │   ├── Test.sqlite
    │   ├── TreeHts.csv
    │   └── trees_treeheights.csv
    └── Sandbox
        ├── by.R
        └── tapply.R

25 directories, 130 files
**********************************************************************

======================================================================
Looking for the weekly directories...

Found 3 weekly directories: Week1, Week2, Week3

The Week2 directory will be assessed 

======================================================================
======================================================================
PART 2: Checking weekly code and workflow...

======================================================================
Assessing WEEK2...

Found the following directories: Code, Data, Sandbox, Results

Found the following files: README

Checking for readme file in weekly directory...

Found README in parent directory, named: README

Printing contents of README:
**********************************************************************
Week two's files. Week two is based aroud the learning and testing of basic python.
	In Code the files are:
	
		align_seqs.py - Opens a CSV file from the Data directory containing 2 DNA sequences. This script 
					   takes these two sequences and finds a best alignment for them. This best alignment
					   is then returned with a score for this alignment (the number of matches).
					   
		align_seqs_fasta.py - This is a modified version of align_seq.py. This script accepts 2 fasta files
							 in the command line and aligns the two sequences on them and returns them in
							 the same way as in align_seq.py

		basic_csv.py - This file gives example code for reading a csv file and printing out the first column of each row
					   with the preceeding text "The species is". The second part of the code takes the file testcsv.csv 
					   and then returns just the first and last columns (species and body mass) and saves the file as 
					   body mass.csv (saved in sandbox)
					   
		basic_io.py - This file gives the example code for opening a file for reading using python.
					  Then the code writes a new file called testout.txt which is the output of 1-100 
					  and saves this file in Sandbox folder (see below). Finally the code gives an example of 
					  storing objects for later use. In this example my_dictionary is stored as the file testp.p
					  in sandbox. Pickle is used to serialize the objects hieracy
					  						
		boilerplate.py - This is a boilerplate function. Displays basic layout of a function and returns "This is a boilerplate "
		
		using_name.py - This file is an example file to give between a function being called upon from elsewhere and running it directly
		
		sysargv.py - This function visually displays how the arguments of a function are found and how argv works
		
		scope.py - This function gives an example bewteen the correct and incorrect way of defining a global variable (retains value after 
				   leaving the function) and the difference of local variables
				   
		control_flow.py - Gives an example of multiple functions within a module and then callign each function seperatly
		
		cfexercise.py - Control flow exercises determining more about the way functions work and how to construcct them
		
		debugme.py - A basic function containing an infinite loop set up to practice using %pdb to debug a program
		
		dictionary.py - Part of chapter 5's practicals. This reads the data file taxa and returns a dictionary that
						links each of the species with their correct order. This dictionary is then printed
						
		lc1.py - Part of chapter 5's practical. Takes the list of birds with there common names, latin names and 
				 body mass and creates 3 seperate lists of just their common names, latin name and body masses 
				 respectively. This is done twice. First using list comprehensiona and then by using loops.
				 
		lc2.py - Part of chapter 5's practical. Uses the provided rainfall data from the met office in 1910, this is then
				 analysed to return two lists. One of the months and corresponding rainfall for the months where the rainfall
				 was greater than 100 mm. The second of just the months that the rainfall was under 50 mm. This is done twice, 
				 first by list comprehensiona and then by using loops.
				 
		LV1.py - The basic Lotka-Volterra model to show the relationship between predator and prey with default arguments.
				 The script integrates the ODE and returns a graph of the results
		
		LV2.py - The modified Lotka-Volterra model for predator prey relationship. This modified script also accepts arguments
				 in the command line to set the values of the constants and the values of these are annotated on the resulting
				 graph	
				 
		LV3.py - The same script as LV2.py but with initial conditions choosen specifically so that the predators and prey have
				 both exist as in a steady state of the population
		
		loops.py - Shows different uses of for and while statements in python code
		
		oaks.py - Gives examples of using list comprehension to return oak species from a list of taxa 
		
		profileme.py - A script with a few useless functions which take a long time to run. This has been designed to practice 
					   profiling a script and working out where it is best to try and speed up the code
		
		run_LV.py - This is part of chapter 6's practicle. The script runs and profiles LV1.py and LV2.py
		
		test_control_flow.py - A modified version of control_flow.py where the function has been isolated and docstring tests have been 
							   added to check that it runs as expected. This was set up to practice the use of docstring tests for 
							   debuging
		
		test_oaks.py - Part of chapter 6's pactical. Program initially ran with a bug so was edited after using docstring tests to determine
					   where the bug was and how to fix it. Now reads the data file of oaks and returns a list of just those that are oaks
		
		timeitme.py - A sript of functions each with two methods of producing the same result. These can each be run with the timeit command
					  to show the difference in time it takes to run each of them
		
		tuple.py - Part of chapter 5's practical. This reads the information stored in the tuples provided and seperates the information for each
				   species onto a seperate line
	
	
	In Data there is: 
		The directory fasta - containing 3 fasta files of genomes that are aligned by being called on and used in the align_seq_fasta.py script
		
		bodymass.csv - see basic_csv
		
		Sequences.py - The csv file containg two DNA sequences to be aligned for the align_seq.py script
		
		testcsv.csv - data for basic_csv.py
		
		TestOaksData.csv - The csv file containg the entire list of species to be analysied by the test_oaks.py script (see above)
		
	
	In Results there is:
		
		align_407228326.fasta_407228412.fasta - The optimal resulting alignment and alignment score from running align_seq_fasta.py on 407228326.fasta 
			                                    and 407228412.fasta both of which are found in the fasta directory within Data

		align_407228326.fasta_E.coli.fasta - The optimal resulting alignment and alignment score from running align_seq_fasta.py on E.coli.fasta 
			                                 and 407228326.fasta both of which are found in the fasta directory within Data	     			                                    

		align_407228412.fasta_E.coli.fasta - The optimal resulting alignment and alignment score from running align_seq_fasta.py on E.coli.fasta 
			                                 and 407228412.fasta both of which are found in the fasta directory within Data
                               
		align_too_few_args_have_an_example - the reusulting example alignment file produced by running align_seq_fasta.py without specifying the two
											 fasta files to be aligned
											 
		JustOaksData.csv - The resuting output from running test_oaks.py. I.e the species from TestOaksData.csv that are species of oak
		
		pey_and_predators_1.pdf - The pdf document of a graph representing the predator prey density relationship that occurs when running the version
								  of the Lotka-Volterra model found in LV1.py
		
		pey_and_predators_2.pdf - The pdf document of a graph representing the predator prey density relationship that occurs when running the modified 
								  version of the Lotka-Volterra model found in LV2.py
								  
		Sequences_aligned.txt - The resulting document of the aligned sequences specified and run from in align_seq.py 
			 	
	
	
	In Sandbox there is:
	
		testout.txt - outputed test file from basic_io.py
	
		testp.p - object written and saved in storing objects example code from basic_io.py
	
		test.txt - file created for practice opening to read in basic_io.py
	
		temp.py - test of for statement
		
		
**********************************************************************

Found 26 code files: lc2.py, boilerplate.py, LV3.py, basic_csv.py, timeitme.py, profileme.py, LV4.py, test_oaks.py, dictionary.py, LV1.py, debugme.py, scope.py, tuple.py, basic_io.py, lc1.py, oaks.py, run_LV.py, LV2.py, loops.py, using_name.py, cfexercises.py, align_seqs.py, sysargv.py, align_seqs_fasta.py, control_flow.py, test_control_flow.py

======================================================================
Testing script/code files...

======================================================================
Inspecting script file lc2.py...

File contents are:
**********************************************************************
#! /usr/bin/python
"""Author - Oliver Tarrant
This is practical lc2. With the rainfall data from the met office for 1910 
This script first creates a list using list comprehension of the months with 
rainfall over 100mm with the corresponding rainfall for each month.
Then the script creates a new list using list comprehension of month with 
rainfall under 50mm, again with corresponding rainfall. 
Finally it recreates these two lists again but this time using 
loops rather than list comprehension."""

######## Instructions #########
# (1) Use a list comprehension to create a list of month,rainfall tuples where
# the amount of rain was greater than 100 mm.
 
# (2) Use a list comprehension to create a list of just month names where the
# amount of rain was less than 50 mm. 

# (3) Now do (1) and (2) using conventional loops (you can choose to do 
# this before 1 and 2 !). 

# ANNOTATE WHAT EVERY BLOCK OR IF NECESSARY, LINE IS DOING! 

# ALSO, PLEASE INCLUDE A DOCSTRING AT THE BEGINNING OF THIS FILE THAT 
# SAYS WHAT THE SCRIPT DOES AND WHO THE AUTHOR IS
# Average UK Rainfall (mm) for 1910 by month
# http://www.metoffice.gov.uk/climate/uk/datasets
#################################

__author__ = 'Oliver Tarrant (oit16@ic.ac.uk)'
__version__ = '0.0.1'

rainfall = (('JAN',111.4),
            ('FEB',126.1),
            ('MAR', 49.9),
            ('APR', 95.3),
            ('MAY', 71.8),
            ('JUN', 70.2),
            ('JUL', 97.1),
            ('AUG',140.2),
            ('SEP', 27.0),
            ('OCT', 89.4),
            ('NOV',128.4),
            ('DEC',142.2),
           )  # enters in the rainfall data

###############Creates a list of months and corresponding rainfall for month where the
#rainfall is >100mm. The second list is of the months whose rainfall is <50mm
#These lists are created with list comprehension#############

#1.

over_100 = set([month[0:2] for month in rainfall if month[1] > 100.0]) # creates a set of the indexs of 0:2 (2 not included) for the months in rainfall where the index 1 is greater than 100mm
print over_100 # prints the corresonding list

#2.

under_50 = set([month[0] for month in rainfall if month[1] < 50.0]) # creates a set of the names (index 1) for the months in rainfall where the index 1 is less than 50mm
print under_50 # prints the corresonding list


##########Creates a list of months and corresponding rainfall for month where the
#rainfall is >100mm. The second list is of the months whose rainfall is <50mm
#These lists are created with loops###############

#3.

over_100_loop = set() #creates an empty set 
for month in rainfall: # creates a for loop to inspect the elements of rainfall
	if month[1] > 100: # checks which months are over 100mm
		over_100_loop.add(month[0:2]) # adds those months with rainfall over 100mm and their rainfall to the set
print over_100_loop # prints the set when all months are checked

under_50_loop = set() #creates an empty set
for month in rainfall: # creates a loop to inspect the elements of rainfall
	if month[1] < 50: #checks which months have rainfall under 50mm
		under_50_loop.add(month[0]) #adds those months whose rainfall is under 50mm
print under_50_loop # prinst the set when all months are checked


**********************************************************************

Testing lc2.py...

lc2.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
set([('JAN', 111.4), ('AUG', 140.2), ('DEC', 142.2), ('FEB', 126.1), ('NOV', 128.4)])
set(['MAR', 'SEP'])
set([('JAN', 111.4), ('AUG', 140.2), ('DEC', 142.2), ('FEB', 126.1), ('NOV', 128.4)])
set(['MAR', 'SEP'])

**********************************************************************

Code ran without errors

Time consumed = 0.02465s

======================================================================
Inspecting script file boilerplate.py...

File contents are:
**********************************************************************
#! /usr/bin/python

""" Author - Oliver Tarrant
 Description of this program
	You can use several lines
	docstring can be accesed at run time"""
	
__author__ = 'Oliver Tarrant (oit16@ic.ac.uk)'
__version__ = '0.0.1'

# imports
import sys # module to interface our program with the operating system

# constants can go here


# functions can go here
def main(argv):
		print 'This is a boilerplate' # NOTE: indented using 2 tabs
		return 0
		
if (__name__== "__main__"): # makes sure thr "main" function is called from command line
		status = main(sys.argv)
		sys.exit(status)
**********************************************************************

Testing boilerplate.py...

boilerplate.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
This is a boilerplate

**********************************************************************

Code ran without errors

Time consumed = 0.01768s

======================================================================
Inspecting script file LV3.py...

File contents are:
**********************************************************************
#! usr/bin/python
""" The typical Lotka-Volterra Model simulated using scipy """

import scipy as sc 
import scipy.integrate as integrate
import pylab as p #Contains matplotlib for plotting
import sys

# import matplotlip.pylab as p #Some people might need to do this

def dR_dt(pops, t=0):
    """ Returns the growth rate of predator and prey populations at any 
    given time step """
    
    R = pops[0]
    C = pops[1]
    dRdt = r*R*(1 - (R/K)) - a*C*R
    dydt = -z*C + e*a*R*C
    
    return sc.array([dRdt, dydt])

if len(sys.argv) >= 5:
	r = float(sys.argv[1])
	a = float(sys.argv[2])
	z = float(sys.argv[3])
	e = float(sys.argv[4])
elif len(sys.argv) == 4:
	r = float(sys.argv[1])
	a = float(sys.argv[2])
	z = float(sys.argv[3])
	e = 0.75
elif len(sys.argv) == 3:	
	r = float(sys.argv[1])
	a = float(sys.argv[2])
	z = 1.5
	e = 0.75
elif len(sys.argv) == 2:	
	r = float(sys.argv[1])
	a = 0.1
	z = 1.5
	e = 0.75
else:
# Define parameters:
	r = 1. # Resource growth rate
	a = 0.1 # Consumer search rate (determines consumption rate) 
	z = 1.5 # Consumer mortality rate
	e = 0.75 # Consumer production efficiency

# Now define time -- integrate from 0 to 15, using 1000 points:
t = sc.linspace(0, 100,  50000)
K = 100
x0 = 10
y0 = 5 
z0 = sc.array([x0, y0]) # initials conditions: 10 prey and 5 predators per unit area

pops, infodict = integrate.odeint(dR_dt, z0, t, full_output=True) #runs dR_dt as an integration with i.c z0 and over time interval t
									# infodict just checks integration was successful
infodict['message']     # >>> 'Integration successful.'

prey, predators = pops.T # Transposes to form correct format 
final_prey = prey[-1]
final_predator = predators[-1]
f1 = p.figure() #Open empty figure object
p.plot(t, prey, 'g-', label='Resource density') # Plot
p.plot(t, predators  , 'b-', label='Consumer density')
p.annotate( 'Constants: r = %r , a = %r , z = %r , e = %r , K = %r' %(r,a,z,e,K), xy=(20,5), color = "red") 
p.annotate('Final prey = %.5s , Final predators = %.5s' %(final_prey,final_predator), xy=(25,2), color = "purple")
p.grid()
p.legend(loc='best')
p.xlabel('Time')
p.ylabel('Population')
p.title('Consumer-Resource population dynamics')
p.show()
f1.savefig('../Results/prey_and_predators_3.pdf') #Save figure
**********************************************************************

Testing LV3.py...

LV3.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 3.27394s

======================================================================
Inspecting script file basic_csv.py...

File contents are:
**********************************************************************
#! usr/bin/python
""" Author - Oliver Tarrant
 This file gives example code for reading a csv file and printing out the first column of each row
with the preceeding text "The species is". The second part of the code takes the file testcsv.csv 
and then returns just the first and last columns (species and body mass) and saves the file as 
body mass.csv (saved in sandbox)"""

import csv

# Read a file containing:
# 'Species','Infraorder','Family','Distribution','Body mass male (Kg)'
f = open('../Data/testcsv.csv','rb')

csvread = csv.reader(f)
temp = [] # Create a blank array
for row in csvread:
	temp.append(tuple(row)) # for each row adds the data from the csv to the array in the form of a tuple
	print row  # prints out the entire information about the species
	print "The species is", row[0] #picks out the species name
	
f.close()

# write a file containing only species name and Body mass
f = open('../Data/testcsv.csv','rb') # opens the csv to read
g = open('../Sandbox/bodymass.csv','wb') # creates a csv to write

csvread = csv.reader(f) # assign names to the open csv
csvwrite = csv.writer(g) 
for row in csvread:
	print row # print rows in the csv to be read
	csvwrite.writerow([row[0], row[4]]) #writes in the new csv the species name and body mass
	
f.close()
g.close() #close the files
**********************************************************************

Testing basic_csv.py...

basic_csv.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
['Species', 'Infraorder', 'Family', 'Distribution', 'Body mass male (Kg)']
The species is Species
['Daubentonia_madagascariensis', 'Chiromyiformes ', 'Daubentoniidae', 'Madagascar', '2.7']
The species is Daubentonia_madagascariensis
['Allocebus_trichotis', 'Lemuriformes', 'Cheirogaleidae', 'Madagascar', '0.1']
The species is Allocebus_trichotis
['Avahi_laniger', 'Lemuriformes', 'Indridae', 'America', '1.03']
The species is Avahi_laniger
['Avahi_occidentalis', 'Lemuriformes', 'Indridae', 'Madagasc
**********************************************************************

Code ran without errors

Time consumed = 0.01295s

======================================================================
Inspecting script file timeitme.py...

File contents are:
**********************************************************************
#! usr/bin/python
"""A test sript for timing different functions usign timeit"""
##########################################################
# range vs. xrange
##########################################################
import time
import timeit

def a_not_useful_function():
	""" Counts from 0 to 100000 using range"""
	y = 0
	for i in range(100000):
		y = y + i
	return 0
	
def a_less_useless_function():
	""" Counts from 0 to 100000 using x range"""
	y = 0
	for i in xrange(100000):
		y = y + i
	return 0
	
# one approach is to time it like this:
start = time.time()
a_not_useful_function()
print "a_less_useless_function takes %f s to run." % (time.time() - start)

start = time.time()
a_less_useless_function()
print "a_less_useless_function takes %f s to run." % (time.time() - start)

# But you'll notice that if you run it multiple times, the time taken changes a
# bit. So instead, you can also run:
#	%timeit a_not_useful_function()
#	%timeit a_less_useless_function()
# in iPython.
##############################################################################
# for loops vs. list comprehensions.
##############################################################################


my_list = range(1000)

def my_squares_loop(x):
	"""Creates a list of squares in range 1000"""
	out = []
	for i in x:
		out.append(i ** 2)
	return out
	
# %timeit my_squares_loop(my_list)
# %timeit my_squares_lc(my_list)



###################################################################
# for loops vs. join method.
###################################################################

import string
my_letters = list(string.ascii_lowercase)

def my_join_loop(l):
	"""Joins the letters in an input string"""
	out = ''
	for letter in l:
		out += letter
	return out
	
	
def my_join_method(l):
	"""Joins the letters in an input string"""
	out = ''.join(l)
	return out
	
	
# %timeit(my_join_loop(my_letters))
# %timeit(my_join_method(my_letters))


#################################################
# Oh dear.
#################################################


def getting_silly_pi():
	"""counts cumulatively from 0 to 100000 using +"""
	y = 0
	for i in xrange(100000):
		y = y + i
	return 0
	
def getting_silly_pii():
	"""Counts cumulatively from 0 to 100000 using +="""
	y = 0
	for i in xrange(100000):
		y += i
	return 0
	
# %timeit(getting_silly_pi())
# %timeit(getting_silly_pii())



**********************************************************************

Testing timeitme.py...

timeitme.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
a_less_useless_function takes 0.005311 s to run.
a_less_useless_function takes 0.002685 s to run.

**********************************************************************

Code ran without errors

Time consumed = 0.02200s

======================================================================
Inspecting script file profileme.py...

File contents are:
**********************************************************************
#! usr/bin/python
"""Author - Oliver Tarrant
A script to practice profiling on"""
def a_useless_function(x):
	"""counts from 0 to 100000000"""
	y = 0
	# eight zeros!
	for i in xrange(100000000):
		y = y + i
	return 0
	
def a_less_useless_function(x):
	"""Counts from 0 to 100000"""
	y = 0
	# five zeros!
	for i in xrange(100000):
		y = y + i
	return 0
	
def some_function(x):
	"""Perfoms a_useless_function and a_less_useless_function"""
	print x
	a_useless_function(x)
	a_less_useless_function(x)
	return 0
	
	
some_function(1000)
**********************************************************************

Testing profileme.py...

profileme.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
1000

**********************************************************************

Code ran without errors

Time consumed = 2.80782s

======================================================================
Inspecting script file LV4.py...

File contents are:
**********************************************************************
#! usr/bin/python
""" The typical Lotka-Volterra Model simulated using scipy """

import scipy as sc 
import scipy.integrate as integrate
import pylab as p #Contains matplotlib for plotting
import sys


# import matplotlip.pylab as p #Some people might need to do this

def dR_dt(x,y, t=0):
    """ Returns the growth rate of predator and prey populations at any 
    given time step """
    # the model
    R = x
    C = y
    dR = R*(1 + r*(1-(R/K))) - a*C*R
    dC = C - z*C + e*a*R*C
    
    return sc.array([[dR, dC]])

if len(sys.argv) >= 5: # Allows uses to input arguments else uses defaults
	r = float(sys.argv[1])
	a = float(sys.argv[2])
	z = float(sys.argv[3])
	e = float(sys.argv[4])
elif len(sys.argv) == 4:
	r = float(sys.argv[1])
	a = float(sys.argv[2])
	z = float(sys.argv[3])
	e = 0.75
elif len(sys.argv) == 3:	
	r = float(sys.argv[1])
	a = float(sys.argv[2])
	z = 1.5
	e = 0.75
elif len(sys.argv) == 2:	
	r = float(sys.argv[1])
	a = 0.1
	z = 1.5
	e = 0.75
else:
# Define parameters:
	r = 1. # Resource growth rate
	a = 0.1 # Consumer search rate (determines consumption rate) 
	z = 1.5 # Consumer mortality rate
	e = 0.75 # Consumer production efficiency

# Now define time -- integrate from 0 to 15, using 1000 points:
t = sc.linspace(0, 15,  13)
K = 100
x0 = 10
y0 = 5
z0 = sc.array([x0, y0]) # initials conditions: 10 prey and 5 predators per unit area
pops = sc.array([[x0,y0]])
x = z0[0]
y = z0[1]
n= len(t)

for i in t[1:n]:
	if x > 0:
		x = x
	else: 
		x = 0
	if y > 0:
		y = y
	else: 
		y = 0
		
	
	new = dR_dt(x,y,i) # 2*1 array
	
	pops = sc.append(pops,new,axis=0) 
	x = round(new[0,0],7)
	y = round(new[0,1],7)



prey, predators = pops.T # Transposes to form correct format 

final_prey = prey[-1]
final_predator = predators[-1]
f1 = p.figure() #Open empty figure object
p.plot(t, prey, 'g-', label='Resource density') # Plot
p.plot(t, predators  , 'b-', label='Consumer density')
p.annotate( 'Constants: r = %r , a = %r , z = %r , e = %r , K = %r' %(r,a,z,e,K), xy=(20,5), color = "red") 
p.annotate('Final prey = %.5s , Final predators = %.5s' %(final_prey,final_predator), xy=(25,2), color = "purple")
p.grid()
p.legend(loc='best')
p.xlabel('Time')
p.ylabel('Population')
p.title('Consumer-Resource population dynamics')
p.show()
f1.savefig('../Results/prey_and_predators_4.pdf') #Save figure
**********************************************************************

Testing LV4.py...

LV4.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 3.27942s

======================================================================
Inspecting script file test_oaks.py...

File contents are:
**********************************************************************
#! /usr/bin/python
"""Author - Oliver Tarrant
Script set up to read a data file of different species and return a list of just those that are oaks"""
import csv
import sys
import ipdb
import doctest
ipdb.set_trace()
#Define function
def is_an_oak(name):
    """ Returns True if name is starts with 'quercus '
        >>> is_an_oak('quercus ')
        True
        >>> is_an_oak('Quercus ')
        True
        >>> is_an_oak('Fagus sylvatica')
        False
        >>> is_an_oak('Quercuss')
        False
        >>> is_an_oak('squercus ')
        False
        >>> is_an_oak('Quercus') #note no space as biuilt into function to avoid longer words
        False
        >>> is_an_oak('blah Quercus ')
        False
    """
    na = name.lower()
    x = na.startswith('quercus ')  
    return x
    
print(is_an_oak.__doc__)

def main(argv): 
    f = open('../Data/TestOaksData.csv','rb')
    g = open('../Results/JustOaksData.csv','wb')
    taxa = csv.reader(f)
    csvwrite = csv.writer(g)
    oaks = set()

    for row in taxa:
        print row
        print "The genus is", row[0]
        if is_an_oak(row[0]+" "): # added space after row[0] to pick up unwanted trailing letters
            print row[0]
            print 'FOUND AN OAK!'
            print " "
            csvwrite.writerow([row[0], row[1]])    
    
    return 0
    
if (__name__ == "__main__"):
    status = main(sys.argv)

doctest.testmod()
**********************************************************************

Testing test_oaks.py...

test_oaks.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
]0;IPython: Week2/Code]0;IPython: Week2/Code> [1;32m/home/mhasoba/Documents/Teaching/IC_CMEE/2017-18/Coursework/StudentRepos/OliverTarrant_OIT16/Week2/Code/test_oaks.py[0m(10)[0;36m<module>[1;34m()[0m
[1;32m      9 [1;33m[1;31m#Define function[0m[1;33m[0m[1;33m[0m[0m
[0m[1;32m---> 10 [1;33m[1;32mdef[0m [0mis_an_oak[0m[1;33m([0m[0mname[0m[1;33m)[0m[1;33m:[0m[1;33m[0m[0m
[0m[1;32m     11 [1;33m    """ Returns True if name is starts with 'quercus '
[0m
ipdb> 

**********************************************************************

Code ran without errors

Time consumed = 0.59876s

======================================================================
Inspecting script file dictionary.py...

File contents are:
**********************************************************************
#! /usr/bin/python
"""Author - Oliver Tarrant
This is practical dictionary.py. This script creates a dictionary called 
taxa_dic which is printed out as a result. This dictionary is formed from 
analysing the dataset taxa and creating a set of taxa for each of the order 
names that are there."""

__author__ = 'Oliver Tarrant (oit16@ic.ac.uk)'
__version__ = '0.0.1'

################INSTRUCTIONS##################
# Write a short python script to populate a dictionary called taxa_dic 
# derived from  taxa so that it maps order names to sets of taxa. 
# E.g. 'Chiroptera' : set(['Myotis lucifugus']) etc. 

# ANNOTATE WHAT EVERY BLOCK OR IF NECESSARY, LINE IS DOING! 

# ALSO, PLEASE INCLUDE A DOCSTRING AT THE BEGINNING OF THIS FILE THAT 
# SAYS WHAT THE SCRIPT DOES AND WHO THE AUTHOR IS

# Write your script here:
##############################################
taxa = [ ('Myotis lucifugus','Chiroptera'),
         ('Gerbillus henleyi','Rodentia',),
         ('Peromyscus crinitus', 'Rodentia'),
         ('Mus domesticus', 'Rodentia'),
         ('Cleithrionomys rutilus', 'Rodentia'),
         ('Microgale dobsoni', 'Afrosoricida'),
         ('Microgale talazaci', 'Afrosoricida'),
         ('Lyacon pictus', 'Carnivora'),
         ('Arctocephalus gazella', 'Carnivora'),
         ('Canis lupus', 'Carnivora'),
        ] #enters the taxa database
        
orders = set([organism[1] for organism in taxa]) # creates a set of all the different orders in the taxa database
dic = {} # creates an empty dictionary
for x in orders: # creates a for loop for each element of set orders
	taxafound_x = list([organism[0] for organism in taxa if organism[1] == '%s' % x]) # for each order this checks the database and creates a list of those organisms for that order 
	new_entry = {'%s' % x: taxafound_x}  # Creates a new entry ready for the dictionary with the order for the current for loop as the key and corresponding list of organisms built line above
	dic.update(new_entry) # adds this new entry to the dictionary
print dic # prints the resulting dictionary







**********************************************************************

Testing dictionary.py...

dictionary.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
{'Rodentia': ['Gerbillus henleyi', 'Peromyscus crinitus', 'Mus domesticus', 'Cleithrionomys rutilus'], 'Afrosoricida': ['Microgale dobsoni', 'Microgale talazaci'], 'Chiroptera': ['Myotis lucifugus'], 'Carnivora': ['Lyacon pictus', 'Arctocephalus gazella', 'Canis lupus']}

**********************************************************************

Code ran without errors

Time consumed = 0.01073s

======================================================================
Inspecting script file LV1.py...

File contents are:
**********************************************************************
#! usr/bin/python
""" The typical Lotka-Volterra Model simulated using scipy """

import scipy as sc 
import scipy.integrate as integrate
import pylab as p #Contains matplotlib for plotting

# import matplotlip.pylab as p #Some people might need to do this

def dR_dt(pops, t=0):
    """ Returns the growth rate of predator and prey populations at any 
    given time step """
    
    R = pops[0]
    C = pops[1]
    dRdt = r*R - a*R*C 
    dydt = -z*C + e*a*R*C
    
    return sc.array([dRdt, dydt])

# Define parameters:
r = 1. # Resource growth rate
a = 0.1 # Consumer search rate (determines consumption rate) 
z = 1.5 # Consumer mortality rate
e = 0.75 # Consumer production efficiency

# Now define time -- integrate from 0 to 15, using 1000 points:
t = sc.linspace(0, 15,  1000)

x0 = 10
y0 = 5 
z0 = sc.array([x0, y0]) # initials conditions: 10 prey and 5 predators per unit area

pops, infodict = integrate.odeint(dR_dt, z0, t, full_output=True) #runs dR_dt as an integration with i.c z0 and over time interval t
									# infodict just checks integration was successful
infodict['message']     # >>> 'Integration successful.'

prey, predators = pops.T # Transposes to form correct format 

f1 = p.figure() #Open empty figure object
p.plot(t, prey, 'g-', label='Resource density') # Plot
p.plot(t, predators  , 'b-', label='Consumer density')
p.grid()
p.legend(loc='best')
p.xlabel('Time')
p.ylabel('Population')
p.title('Consumer-Resource population dynamics')
p.show()
f1.savefig('../Results/prey_and_predators_1.pdf') #Save figure
**********************************************************************

Testing LV1.py...

LV1.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 3.95298s

======================================================================
Inspecting script file debugme.py...

File contents are:
**********************************************************************
#! usr/bin/python
""" Author - Oliver Tarrant
Script for practice debugging with using ipdb"""

def createabug(x):
	y = x**4
	z = 0.
	y = y/z
	return y
	
createabug(25)
**********************************************************************

Testing debugme.py...

debugme.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Encountered error:
Traceback (most recent call last):
  File "debugme.py", line 11, in <module>
    createabug(25)
  File "debugme.py", line 8, in createabug
    y = y/z
ZeroDivisionError: float division by zero

======================================================================
Inspecting script file scope.py...

File contents are:
**********************************************************************
#! usr/bin/python
""" Author - Oliver Tarrant
Demonstrates the use of global variables. The first funtion failes to run
		properly because the variable _a_global is not defined as a global variable
		whilst the second one does as it is correctly defined"""

## Try this first

#~ _a_gloabl = 10

#~ def a_function():
	#~ _a_global = 5
	#~ _a_local = 4
	#~ print "Inside the function, the value is ", _a_global
	#~ print "Inside the function, the value is ", _a_local
	#~ return None
	
#~ a_function()
#~ print "Outside the function, the value is ", _a_global



## Now try this

_a_global = 10

def a_function():
	global _a_global # defined as a global variable
	_a_global = 5
	_a_local = 4
	print "Inside the function the value is ", _a_global
	print "Inside the function the value is ", _a_local
	return None
	
a_function()
print "Outside the function, the value is", _a_global
**********************************************************************

Testing scope.py...

scope.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
Inside the function the value is  5
Inside the function the value is  4
Outside the function, the value is 5

**********************************************************************

Code ran without errors

Time consumed = 0.01173s

======================================================================
Inspecting script file tuple.py...

File contents are:
**********************************************************************
#! /usr/bin/python
"""Author - Oliver Tarrant
This is practical tuple.py. This takes the dataset birds and neatens it
up so that each species has it's own seperate line and the text has 
quotation marks removed and commas added between latin name, common name
and mass """

__author__ = 'Oliver Tarrant (oit16@ic.ac.uk)'
__version__ = '0.0.1'



birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
        )

# Birds is a tuple of tuples of length three: latin name, common name, mass.
# write a (short) script to print these on a separate line for each species
# Hints: use the "print" command! You can use list comprehensions!

# ANNOTATE WHAT EVERY BLOCK OR IF NECESSARY, LINE IS DOING! 

# ALSO, PLEASE INCLUDE A DOCSTRING AT THE BEGINNING OF THIS FILE THAT 
# SAYS WHAT THE SCRIPT DOES AND WHO THE AUTHOR IS
	
for latin_name, common_name, mass in birds: # defines each element of the tuples in birds
	print latin_name + ', ' + common_name + ', ' + str(mass) # prints a string with the elements combined and the text neatened

**********************************************************************

Testing tuple.py...

tuple.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
Passerculus sandwichensis, Savannah sparrow, 18.7
Delichon urbica, House martin, 19
Junco phaeonotus, Yellow-eyed junco, 19.5
Junco hyemalis, Dark-eyed junco, 19.6
Tachycineata bicolor, Tree swallow, 20.2

**********************************************************************

Code ran without errors

Time consumed = 0.01289s

======================================================================
Inspecting script file basic_io.py...

File contents are:
**********************************************************************
#! usr/bin/python
"""Author - Oliver Tarrant
This file gives the example code for opening a file for reading using python.
Then the code writes a new file called testout.txt which is the output of 1-100 
and saves this file in Sandbox folder (see below). Finally the code gives an example of 
storing objects for later use. In this example my_dictionary is stored as the file testp.p
in sandbox. Pickle is used to serialize the objects hieracy"""


########################
# FILE INPUT
########################
# Open a file for reading
f = open('../Sandbox/test.txt',	'r')
# use "implicit" for loop:
# if the object is a file, python will cycle over lines
for line in f:
	print line, # the "," prevents adding a new line
		
# close the file
f.close()

# same example, skip blank lines
f = open('../Sandbox/test.txt',	'r')
for line in f:
	if len(line.strip()) > 0: #removes trailing and leading spaces from line and determines if it is non blank
		print line,
		
f.close()


#################
# FILE OUTPUT
#################
list_to_save = range(100)

f = open('../Sandbox/testout.txt','w')
for i in list_to_save:
	f.write(str(i) + '\n') ## Add a new line at the end
	
f.close()

####################
# STORING OBJECTS
####################
# To save an object (even complex) for later use
my_dictionary = {"a key": 10, "another key": 11}

import pickle

f = open('../Sandbox/testp.p','wb') ## note the b: accept binary files
pickle.dump(my_dictionary, f)
f.close()
## Load the data again
f = open('../Sandbox/testp.p','rb')
another_dictionary = pickle.load(f)
f.close()

print another_dictionary
**********************************************************************

Testing basic_io.py...

basic_io.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
First Line 
Second Line

Third Line

Fourth Line
First Line 
Second Line
Third Line
Fourth Line
{'another key': 11, 'a key': 10}

**********************************************************************

Code ran without errors

Time consumed = 0.01427s

======================================================================
Inspecting script file lc1.py...

File contents are:
**********************************************************************
#! /usr/bin/python
"""Author - Oliver Tarrant
lc1 practical in which the list of birds is taken and list comprehension is used to create
three seperate lists, first with the latin names, second with common names and third with 
mean body mass. Then three further lists are created. These are repeats of the first three 
but are formed using loops rather than list comprehension"""

################INSTRUCTIONS###################
#(1) Write three separate list comprehensions that create three different
# lists containing the latin names, common names and mean body masses for
# each species in birds, respectively. 

# (2) Now do the same using conventional loops (you can shoose to do this 
# before 1 !). 

# ANNOTATE WHAT EVERY BLOCK OR, IF NECESSARY, LINE IS DOING! 

# ALSO, PLEASE INCLUDE A DOCSTRING AT THE BEGINNING OF THIS FILE THAT 
# SAYS WHAT THE SCRIPT DOES AND WHO THE AUTHOR IS
################################################

__author__ = 'Oliver Tarrant (oit16@ic.ac.uk)'
__version__ = '0.0.1'

import sys # module to interface our program with the operating system


birds = ( ('Passerculus sandwichensis','Savannah sparrow',18.7),
          ('Delichon urbica','House martin',19),
          ('Junco phaeonotus','Yellow-eyed junco',19.5),
          ('Junco hyemalis','Dark-eyed junco',19.6),
          ('Tachycineata bicolor','Tree swallow',20.2),
         )   # enters the dataset birds
         
###############Creating lists of latin names, common names and body masses respectively using list comprehension###########
 
 #1.     
    
Latin_names = set([bird[0] for bird in birds]) # creates a set of all the zero index enties (latin names) from all entries in dataset birds
print Latin_names # prints the resulting list of latin names

Common_names = set([bird[1] for bird in birds]) # creates a set of all the 1 index entries (common names) from all entries in dataset birds
print Common_names # prints the resulting list of common names

Body_masses = set([bird[2] for bird in birds]) # creates a set of all the last (2) index entries (body masses) from all entries in dataset birds
print Body_masses # prints the resulting list of body masses


###############Creating lists of latin names, common names and body masses respectively using loops################

#2.

latin_names_loops = set() # defines an empty set for latin names
for bird in birds: # sets up a for loop to check all elements of birds
	latin_names_loops.add(bird[0]) # adds the zero index of each entry in birds to the set created
print latin_names_loops # prints the resulting list

common_names_loops = set() # defines an empty set for common names
for bird in birds: # sets up a for loop to check all elements of birds
	common_names_loops.add(bird[1]) # adds the 1 index of each entry in birds to the set created
print common_names_loops # prints the resulting list

body_masses_loops = set() # defines an empty set for bady masses
for bird in birds: # sets up a for loop to check all elements of birds
	body_masses_loops.add(bird[2]) # adds the last (2) index of each entry in birds to the set created
print body_masses_loops # prints the resulting list

**********************************************************************

Testing lc1.py...

lc1.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
set(['Junco hyemalis', 'Passerculus sandwichensis', 'Junco phaeonotus', 'Tachycineata bicolor', 'Delichon urbica'])
set(['Savannah sparrow', 'House martin', 'Dark-eyed junco', 'Yellow-eyed junco', 'Tree swallow'])
set([19.5, 20.2, 19, 18.7, 19.6])
set(['Junco hyemalis', 'Passerculus sandwichensis', 'Junco phaeonotus', 'Tachycineata bicolor', 'Delichon urbica'])
set(['Savannah sparrow', 'House martin', 'Dark-eyed junco', 'Yellow-eyed junco', 'Tree swallow'])
set([19.5, 20.2, 19, 18.7, 19.6])

**********************************************************************

Code ran without errors

Time consumed = 0.01160s

======================================================================
Inspecting script file oaks.py...

File contents are:
**********************************************************************
#! usr/bin/python
""" Author - Oliver Tarrant
A script to return which species are oaks from a list of taxa"""


## Let's find just those taxa that are oak trees from a list of species

taxa = [ 'Quercus robur', 'Fraxinus excelsior', 'Pinus sylvestris', 'Quercus cerris', 'Quercus petraea' ]
# initial list of species
def is_an_oak(name): # creates a function to test if a species is an oak or not
	"""Checks the argument and returns true is it is an oak"""
	return name.lower().startswith('quercus ') #returns a True or False depending if it is an oak
	
## call using for loops
oaks_loops = set()
for species in taxa:
	if is_an_oak(species):
		oaks_loops.add(species)
print oaks_loops # checks using above function if each is an oak and returns the set of oaks

## call using list comprehensions
oaks_lc = set([species for species in taxa if is_an_oak(species)])
print oaks_lc  # checks each iteam in the list if it is an oak or not and creates a set of those that are

## call and get names in UPPER CASE using for loops
oaks_loops = set()
for species in taxa:   #checks each iteam in the list
	if is_an_oak(species): # checks using first function if it is an oak
		oaks_loops.add(species.upper()) # adds thos that are oaks in upper case to the set oaks_loops
print oaks_loops # prints the set of oaks

## call and get names in UPPER CASE usign list comprehension
oaks_lc = set([species.upper() for species in taxa if is_an_oak(species)]) #defines the set and tells you to add in upper case all those species in taxa that return True to is_an_oak
print oaks_lc #prints the set 
**********************************************************************

Testing oaks.py...

oaks.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
set(['Quercus robur', 'Quercus cerris', 'Quercus petraea'])
set(['Quercus robur', 'Quercus cerris', 'Quercus petraea'])
set(['QUERCUS ROBUR', 'QUERCUS CERRIS', 'QUERCUS PETRAEA'])
set(['QUERCUS ROBUR', 'QUERCUS CERRIS', 'QUERCUS PETRAEA'])

**********************************************************************

Code ran without errors

Time consumed = 0.01140s

======================================================================
Inspecting script file run_LV.py...

File contents are:
**********************************************************************
#! usr/bin/python
"""A script to run  and profile the LV*.py files"""
import os
import cProfile


os.system("python -m cProfile LV1.py") # runs a profiles each script with arguments if given
os.system("python -m cProfile LV2.py 1.2 0.12 1.4 0.9")

**********************************************************************

Testing run_LV.py...

run_LV.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
         415257 function calls (408415 primitive calls) in 2.680 seconds

   Ordered by: standard name

   ncalls  tottime  percall  cumtime  percall filename:lineno(function)
        1    0.000    0.000    0.000    0.000 <decorator-gen-0>:1(<module>)
        1    0.000    0.000    0.000    0.000 <decorator-gen-1>:1(<module>)
        1    0.000    0.000    0.000    0.000 <decorator-gen-2>:1(<module>)
        1    0.000    0.000    0.000    0.000 <decorator-gen-3>:1(<module>)
        1    0.000   
**********************************************************************

Code ran without errors

Time consumed = 5.96337s

======================================================================
Inspecting script file LV2.py...

File contents are:
**********************************************************************
#! usr/bin/python
""" The typical Lotka-Volterra Model simulated using scipy """

import scipy as sc 
import scipy.integrate as integrate
import pylab as p #Contains matplotlib for plotting
import sys

# import matplotlip.pylab as p #Some people might need to do this

def dR_dt(pops, t=0):
    """ Returns the growth rate of predator and prey populations at any 
    given time step """
    
    R = pops[0]
    C = pops[1]
    dRdt = r*R*(1 - (R/K)) - a*C*R
    dydt = -z*C + e*a*R*C
    
    return sc.array([dRdt, dydt])

if len(sys.argv) >= 5:
	r = float(sys.argv[1])
	a = float(sys.argv[2])
	z = float(sys.argv[3])
	e = float(sys.argv[4])
elif len(sys.argv) == 4:
	r = float(sys.argv[1])
	a = float(sys.argv[2])
	z = float(sys.argv[3])
	e = 0.75
elif len(sys.argv) == 3:	
	r = float(sys.argv[1])
	a = float(sys.argv[2])
	z = 1.5
	e = 0.75
elif len(sys.argv) == 2:	
	r = float(sys.argv[1])
	a = 0.1
	z = 1.5
	e = 0.75
else:
# Define parameters:
	r = 1. # Resource growth rate
	a = 0.1 # Consumer search rate (determines consumption rate) 
	z = 1.5 # Consumer mortality rate
	e = 0.75 # Consumer production efficiency

# Now define time -- integrate from 0 to 15, using 1000 points:
t = sc.linspace(0, 50,  5000)
K = 250
x0 = 10
y0 = 5 
z0 = sc.array([x0, y0]) # initials conditions: 10 prey and 5 predators per unit area

pops, infodict = integrate.odeint(dR_dt, z0, t, full_output=True) #runs dR_dt as an integration with i.c z0 and over time interval t
									# infodict just checks integration was successful
infodict['message']     # >>> 'Integration successful.'

prey, predators = pops.T # Transposes to form correct format 
f1 = p.figure() #Open empty figure object
p.plot(t, prey, 'g-', label='Resource density') # Plot
p.plot(t, predators  , 'b-', label='Consumer density')
p.annotate( 'r = %r , a = %r , z = %r , e = %r , K = %r' %(r,a,z,e,K), xy=(18,1), color = "red") 
p.grid()
p.legend(loc='best')
p.xlabel('Time')
p.ylabel('Population')
p.title('Consumer-Resource population dynamics')
p.show()
f1.savefig('../Results/prey_and_predators_2.pdf') #Save figure
**********************************************************************

Testing LV2.py...

LV2.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 3.56751s

======================================================================
Inspecting script file loops.py...

File contents are:
**********************************************************************
#! usr/bin/python
""" Author - Oliver Tarrant
 A script demonstrating the differnt ways of using loops in python"""

# for loops in Python
for i in range(5):
	print i # prints numbers 0,1,2,3,4 (note starts at 0 as python index starts at 0)
	

my_list = [0,2,"geronimo!", 3.0, True, False]
for k in my_list:
	print k
	# returns my_list, each entry on a new line
	
total = 0
summands = [0, 1, 11, 111, 1111]
for s in summands:
	total = total + s
	print total + s   # prints the cumulative sum of list summands
	

# while loops in Python
z = 0
while z < 100: # checks if value of z is < 100 and if so enters the while loop
	z = z + 1 # increases z to next integer
	print (z) # prints this integer then returns to begining of while loop
			  # ie checks if this value is still less than 100
			  
b = True
while b:
	print "GERONIMO! infinite loop! ctrl+c to stop!"
	# ctrl + c to stop
	
**********************************************************************

Testing loops.py...

loops.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
0
1
2
3
4
0
2
geronimo!
3.0
True
False
0
2
23
234
2345
1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c to stop!
GERONIMO! infinite loop! ctrl+c
**********************************************************************

Code ran without errors

Time consumed = 10.61884s

======================================================================
Inspecting script file using_name.py...

File contents are:
**********************************************************************
#! /usr/bin/python
# Filename: using_name.py
"""Author - Oliver Tarrant 
A script showing how name = main works"""
if __name__== '__main__':
	print 'This program is being run by itself'
else:
	print 'I am being imported from another module'
**********************************************************************

Testing using_name.py...

using_name.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
This program is being run by itself

**********************************************************************

Code ran without errors

Time consumed = 0.01860s

======================================================================
Inspecting script file cfexercises.py...

File contents are:
**********************************************************************
#! /usr/bin/python

"""Author - Oliver Tarrant 
Some exercises derived from original script of cfexercises to convert 
it into a module"""
__author__ = 'Oliver Tarrant (oit16@ic.ac.uk)'
__version__ = '0.0.1'

import sys # module to interface our program with operating system

# How many times will 'hello' be printed?
# 1)

for i in range(3,17):
	# prints hello for each value in the index within the range 3,17
	print 'hello'
	# answer = 14

# 2) 

for j in range(12):
	#Prints hello each time j modulo 3 = 0 i.e for 0,3,6,9
	if j % 3 == 0:
		print 'hello'
	# answer = 4

# 3)

for j in range(15):
	#Prints hello each time j  modulo 5 is 3 or j modulo 4 is 3
	if j % 5 == 3:
		print 'hello'
	elif j % 4 == 3:
		print 'hello'
	# answer = 5
	
# 4) 

z = 0
while z != 15:
	# Prints hello whenever z is not equal to 15. z starts at 0 and increases by 3 each 
	# pass through the while loop
	print 'hello'
	z = z + 3
	# answer = 5
	
# 5) 

z = 12	
while z < 100:
	# z starts at 12 and increases by 1 each run through the loop
	#until it reaches 18 then enters the elif section and prints hello. 
	#continues to increase to 31 which then enters the if statement and
	#prints hello 7 times as k counts from 0 to 6 (range(7))
	if z == 31:
		for k in range(7):
			print 'hello'
	elif z == 18:
		print 'hello'
	z = z + 1
	# answer = 8 
	
# What does fooXX do?

def foo1(x):
	"""Returns the square root of x"""
	return x ** 0.5


def foo2(x,y):
	"""Returns the larger of x and y"""
	if x > y:
		return x
	return y
	
	

def foo3(x,y,z):
	"""Reorders x and y to put largest first then does the same with the new value in the 
	y position and the z"""
	if x > y:
		tmp = y 
		y = x
		x = tmp
	if y > z:
		tmp = z
		z = y
		y = tmp
	return [x,y,z]
	
	
	
def foo4(x):
	"""Returns x factorial"""
	result = 1
	for i in range(1, x + 1):
		result = result * i
	return result
	


# This is a recursive function, meaning that the function calls itself
# read about it at 
# en.wikipedia.org/wiki/Recursion_(computer_science)
"""Returns x factorial"""
def foo5(x):
	if x == 1:
		return 1
	return x * foo5(x - 1)
	
foo5(10)	


def main(argv):
# prints examples of each fooxx function running
	print foo1(25)
	print foo2(33,22)
	print foo3(120,235,12)
	print foo4(8)
	print foo5(3)
	return 0		

if (__name__ == "__main__"):
	status = main(sys.argv)
	sys.exit(status)

**********************************************************************

Testing cfexercises.py...

cfexercises.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
hello
5.0
33
[120, 12, 235]
40320
6

**********************************************************************

Code ran without errors

Time consumed = 0.01041s

======================================================================
Inspecting script file align_seqs.py...

File contents are:
**********************************************************************
#! /usr/bin/python
""" AUthor - Oliver Tarrant
 Genetic sequence alignment script. Takes a csv file of two DNA sequences and aligns them 
returning the best alignment score"""

__author__ = 'Oliver Tarrant (oit16@ic.ac.uk)'
__version__ = '0.0.1'

import csv
import sys

# Opening the input csv file and reads the two sequences as a list, 
#donoting each sequence as seq1 & seq 2 respectively 
with open('../Data/Sequences.csv', 'rb') as seqcsv:
	seq = list(csv.reader(seqcsv, delimiter = ','))
	seq1 = seq[0][0]
	seq2 = seq[0][1]
# These are the two sequences to match
seqcsv.close()
	# assign the longest sequence s1, and the shortest to s2
# l1 is the length of the longest, l2 that of the shortest
l1 = len(seq1)
l2 = len(seq2)
if l1 >= l2:
	s1 = seq1
	s2 = seq2
else:
	s1 = seq2
	s2 = seq1
	l1, l2 = l2, l1 # swap the two lengths

# function that computes a score
# by returning the number of matches 
# starting from arbitrary startpoint
def calculate_score(s1, s2, l1, l2, startpoint):
	"""Given two strings with their lengths given and a start point
	this function aligns the two sequences starting at this start point
	and returns the resulting alignment along with its score"""
	# startpoint is the point at which we want to start
	matched = "" # contains string for alignement
	score = 0
	for i in range(l2):
		if (i + startpoint) < l1:
			# if its matching the character
			if s1[i + startpoint] == s2[i]:
				matched = matched + "*"
				score = score + 1
			else:
				matched = matched + "-"
	return score
	# now try to find the best match (highest score)
my_best_align = None
my_best_score = -1
for i in range(l1):
	z = calculate_score(s1, s2, l1, l2, i)
	if z > my_best_score:
		my_best_align = "." * i + s2
		my_best_score = z
	#creates a new output file to write results in
f = open('../Results/Sequences_aligned.txt','w+')
outtext = ["Best alignment:" + "\n", my_best_align + "\n", s1 + "\n", "\n","Best score:" + str(my_best_score)]
f.writelines(outtext) # requires a list input as generated above
f.close() 
**********************************************************************

Testing align_seqs.py...

align_seqs.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.01097s

======================================================================
Inspecting script file sysargv.py...

File contents are:
**********************************************************************
#! usr/bin/python
""" Author - Oliver Tarrant
A script to show how sys.argv works and can be called"""

import sys
print "This is the name of the script: ", sys.argv[0]
print "Number of arguments: ", len(sys.argv)
print "The arguments are: " , str(sys.argv)
**********************************************************************

Testing sysargv.py...

sysargv.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
This is the name of the script:  sysargv.py
Number of arguments:  1
The arguments are:  ['sysargv.py']

**********************************************************************

Code ran without errors

Time consumed = 0.01255s

======================================================================
Inspecting script file align_seqs_fasta.py...

File contents are:
**********************************************************************
#! /usr/bin/python
""" Author - Oliver Tarrant
 Genetic sequence alignment script. Takes a csv file of two DNA sequences and aligns them 
returning the best alignment score"""

__author__ = 'Oliver Tarrant (oit16@ic.ac.uk)'
__version__ = '0.0.1'

import csv
import sys
# Checks that arguments given are correct else tells the user how to use the function
if len(sys.argv) < 3 : 
	with open('../Data/fasta/407228326.fasta' , 'rb') as seq:
		seq1 = list(csv.reader(seq, delimiter = '\n'))
		seq1 = seq1[1:]
		seq1 = sum(seq1,[])
		seq1 = ''.join(seq1)
	with open('../Data/fasta/407228412.fasta' , 'rb') as seqf:
		seq2 = list(csv.reader(seqf, delimiter = '\n'))
		seq2 = seq2[1:]
		seq2 = sum(seq2,[])
		seq2 = ''.join(seq2)			

	name1 = "too_few_args"
	name2 = "have_an_example" 
	
#Converts the fasta files into lists so that they can be aligned using the same method as in align_seq.py
else: 	
	seq1 = sys.argv[1] 
	seq2 = sys.argv[2]
	name1 = seq1.split("/",1000)[-1] #neatens up the file names for reference in output file good
	name2 = seq2.split("/",1000)[-1]
	with open(seq1, 'rb') as seq:
		seq1 = list(csv.reader(seq, delimiter = '\n'))
		seq1 = seq1[1:]
		seq1 = sum(seq1,[])
		seq1 = ''.join(seq1)
		 
	with open(seq2, 'rb') as seqf:
		seq2 = list(csv.reader(seqf, delimiter = '\n'))
		seq2 = seq2[1:]
		seq2 = sum(seq2,[])
		seq2 = ''.join(seq2)			

	# assign the longest sequence s1, and the shortest to s2
	# l1 is the length of the longest, l2 that of the shortest

l1 = len(seq1)
l2 = len(seq2)
if l1 >= l2:
	s1 = seq1
	s2 = seq2
else:
	s1 = seq2
	s2 = seq1
	l1, l2 = l2, l1 # swap the two lengths

# function that computes a score
# by returning the number of matches 
# starting from arbitrary startpoint
def calculate_score(s1, s2, l1, l2, startpoint):
	# startpoint is the point at which we want to start
	matched = "" # contains string for alignement
	score = 0
	for i in range(l2):
		if (i + startpoint) < l1:
			# if its matching the character
			if s1[i + startpoint] == s2[i]:
				matched = matched + "*"
				score = score + 1
			else:
				matched = matched + "-"
	return score
	# now try to find the best match (highest score)
my_best_align = None
my_best_score = -1
for i in range(l1):
	z = calculate_score(s1, s2, l1, l2, i)
	if z > my_best_score:
		my_best_align = "." * i + s2
		my_best_score = z
	#Open the output file and write the best alignment and alignment score in the file
	#f = open('../Results/align_%s_%s' % ('sys.argv[1]' , 'sys.argv[2]'),'w+') 
f = open('../Results/align_%s_%s' % (name1 , name2),'w+') 	
outtext = ["Best alignment:" + "\n", my_best_align + "\n", s1 + "\n", "\n","Best score:" + str(my_best_score)]
f.writelines(outtext) # requires a list input as generated above
f.close() 
**********************************************************************

Testing align_seqs_fasta.py...

align_seqs_fasta.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 2.53260s

======================================================================
Inspecting script file control_flow.py...

File contents are:
**********************************************************************
#! /usr/bin/python

""" Author - Oliver Tarrant
 Some functions exemplfying the use of control statements"""
#docstrings are considered part of the running code (normal comments are
#stripped) . Hence you can access your docstrings at run time.
__author__ = 'Oliver Tarrant (oit16@ic.ac.uk)'
__version__ = '0.0.1'

# imports
import sys # module to interface our program with the operating system

# constants can go here
def even_or_odd(x=0): #if not specified, x should take the value 0
	
	"""Find whether a number x is even or odd."""
	if x % 2 == 0: #The conditional if. Checking if x divided by 2 leaves remainder 0
		return "%d is Even!" % x   # %d is a space holder for a number %x afterwards is needed to refer to x beingn where the number is taken from
	return "%d is Odd!" % x
	
def largest_divisor_five (x=120) :
	"""Find which is the largest divisor of x amoung 2,3,4,5."""
	largest = 0
	if x % 5 == 0:
		largest = 5
	elif x % 4 == 0: #means "else if" 
		largest = 4
	elif x % 3 == 0:
		largest = 3
	elif x % 2 == 0:
		largest = 2
	else: #when all other (if, elif) conditions are not met
		return "No divisor found for %d!" % x # Each function can return a variable
	return "The largest divisor of %d is %d" % (x, largest) # Note tuple needed for multiple stored values

def is_prime(x=70):
	"""Find whether an integer is prime."""
	for i in range (2,x): # "range" returns a sequence of integers
		if x % i == 0:
			print "%d is not a prime: %d is a divisor" % (x,i) #Print formatted text "%d %s %f %e" % (20,"30",0.0003,0.00003)
			
			return False
	print "%d is a prime!" % x
	return True
	
def find_all_primes(x=22):
	"""Find all the primes up to x"""
	allprimes=[]    # sets initial list to 0
	for i in range(2, x + 1): # gives range to check in
		if is_prime(i): # uses above function to test if each number in range is prime
			allprimes.append(i) # if a number in the range is prime then it is added to the list of primes
	print "There are %d primes between 2 and %d" % (len(allprimes), x)  # returns the length of the list of primes
	return allprimes #returns the primes
	
def main(argv):
	# sys.exit("don't want to do this right now!")
	print even_or_odd(22)
	print even_or_odd(33)
	print largest_divisor_five(120)
	print largest_divisor_five(121)
	print is_prime(60)
	print is_prime(59)
	print find_all_primes(100) # demonstrates that functions work
	return 0   # sign of success
	
if (__name__ == "__main__"):
	status = main(sys.argv)
	sys.exit(status)
**********************************************************************

Testing control_flow.py...

control_flow.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************
22 is Even!
33 is Odd!
The largest divisor of 120 is 5
No divisor found for 121!
60 is not a prime: 2 is a divisor
False
59 is a prime!
True
2 is a prime!
3 is a prime!
4 is not a prime: 2 is a divisor
5 is a prime!
6 is not a prime: 2 is a divisor
7 is a prime!
8 is not a prime: 2 is a divisor
9 is not a prime: 3 is a divisor
10 is not a prime: 2 is a divisor
11 is a prime!
12 is not a prime: 2 is a divisor
13 is a prime!
14 is not a prime: 2 is a divisor
15 is not a prime: 3 is a divisor
16 is 
**********************************************************************

Code ran without errors

Time consumed = 0.01026s

======================================================================
Inspecting script file test_control_flow.py...

File contents are:
**********************************************************************
#! /usr/bin/python

""" Author - Oliver Tarrant 
Some functions exemplfying the use of control statements"""

__author__ = 'Oliver Tarrant (oit16@ic.ac.uk)'
__version__ = '0.0.1'

# imports
import sys 
import doctest # Import the doctest module


def even_or_odd(x=0): #if not specified, x should take the value 0
	"""Find whether a number x is even or odd.
	
	>>> even_or_odd(10)
	'10 is Even!'
	
	>>> even_or_odd(5)
	'5 is Odd!'
	
	whenever a float if provided, then the closest integer is used:
	>>> even_or_odd(3.2)
	'3 is Odd!'
	
	In the case of negative numbers, the positive is taken:
	>>> even_or_odd(-2)
	'-2 is Even!'
	
	"""
	# define function to be tested
	
	if x % 2 == 0: #The conditional if. Checking if x divided by 2 leaves remainder 0
		return "%d is Even!" % x   # %d is a space holder for a number %x afterwards is needed to refer to x beingn where the number is taken from
	return "%d is Odd!" % x

###### Suppressed this block as just using docstring tests to detrmine if the function works so don't want to run unnessary code #########
	

#~ def main(argv):
	#~ print even_or_odd(22)
	#~ print even_or_odd(33)
	#~ return 0


	
#~ if (__name__ == "__main__"):
	#~ status = main(sys.argv)
	#~ sys.exit(status)
	
	
##########################################	

doctest.testmod() # To run with embedded tests



**********************************************************************

Testing test_control_flow.py...

test_control_flow.py is a Python script file;
 checking for docstrings...

Found one or more doctrings!

Output (only first 500 characters): 

**********************************************************************

**********************************************************************

Code ran without errors

Time consumed = 0.03688s

======================================================================
======================================================================
Finished running scripts

Ran into 1 errors

======================================================================
======================================================================

FINISHED WEEKLY ASSESSMENT

Current Marks for the Week = 100

NOTE THAT THESE ARE NOT THE FINAL MARKS FOR THE WEEK, BUT AN UPPER BOUND ON THE MARKS!